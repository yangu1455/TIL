230406 1교시 강의 내용 정리   

<br>

useState vs useReducer

useState
* 간단한 상태 관리에 많이 쓰인다!
  * 변수의 값이 하나인 경우
  * 상태들(변수들)이 서로 관련이 없는 경우
* 컴포넌트 내에서 사용

```javascript
// 기본형
// const [state, setState] = useState(initialState);
// useState가 useReducer를 기반으로 만들어졌는데 값이 하나니까 reducer가 빠진 형태

import React, { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Count: {count}</p>
      <button onclick={() => setCount(count + 1)}>Increment</button>
      <button onclick={() => setCount(count - 1)}>Decrement</button>
    </div>
  )
}
```

```javascript
import React, { useState } from 'react';

function SimpleForm() {
  const [username, setUsername] = useState('');
  const [email, setEmail] = useState('');

  const handleSubmit = (e) => {
    e.preventDefault();
    console.log(`Username: ${username}, Email: ${email}`);
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="text"
        placeholder="Username"
        value={username}
        onChange={(e) => setUsername(e.target.value)}
      />
      <input
        type="email"
        placeholder="Email"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
      />
      <button type="submit">Submit</button>
    </form>
  );
}
```

useState 사용시 주의사항
1. State as a Snapshot
2. 함수형 프로그래밍의 원칙
3. 'batch'
4. Update queue
5. 반복문 안에서 상태를 업데이트 하는 경우


useReducer
* 복잡한 상태관리
  * 상태들이 서로 관련이 있거나, 참조가 필요한 경우
  * 로그인된 사용자의 권한을 확인해서 다른 화면을 보여준다거나 하는 경우
* 여러 컴포넌트에서 상태가 공유되어야할 때
  * ContextAPI(useContext) 사용시 사용하는 것이 일반적
* reducer를 따로 선언하는 것이 일반적

```javascript
const [state, dispatch] = useReducer(reducer, initialState);
```

1. e.commerce에서 제품, 카테고리, 주문 정보, 사용자 정보, 쿼리정보 등을 담아야 할 때

```javascript
const initialState = {
  products: [], 
  categories: [],
  orders: [],
  user: null,
  searchQuery: '',
  filters: {},
  sorting: { field: 'name', direction: 'asc' },
  pagination: { currentPage: 1, itemsPerPage: 10 },
  theme: 'light',
  loading: false,
};
```

```javascript
function reducer(state, action) {
  switch (action.type) {
    case 'SET_PRODUCTS':
      return { ...state, products: action.payload };
    case 'SET_CATEGORIES':
      return { ...state, categories: action.payload };
    case 'SET_ORDERS':
      return { ...state, orders: action.payload };
    case 'SET_USER':
      return { ...state, user: action.payload };
    case 'SET_SEARCH_QUERY':
      return { ...state, searchQuery: action.payload };
    case 'SET_FILTERS':
      return { ...state, filters: action.payload };
    case 'SET_SORTING':
      return { ...state, sorting: action.payload };
    case 'SET_PAGINATION':
      return { ...state, pagination: action.payload };
    case 'TOGGLE_THEME':
      return { ...state, theme: state.theme === 'light' ? 'dark' : 'light' };
    case 'SET_LOADING':
      return { ...state, loading: action.payload };
    default:
      return state;
  }
}
```

```javascript
function EcommerceDashboard() {
  const [state, dispatch] = useReducer(reducer, initialState);

  // ... component logic to fetch data, handle user interactions ...~

  return (
    // ... JSX to render the dashboard, display data, and handle
  );
}
```

useState vs useReducer

1. useState만 써서 충분한 경우가 대부분
2. useReduce를 사용하는 것이 효율적인 경우
  * 관리해야하는 상태가 많을 때
  * 상태들이 서로 관련이 있는 경우
  * 비즈니스 로직 분리
  * Immutability
3. useContext 설명할 때 예제코드와 같이 상세히 다룰 예정

<br>
<br>

useMemo vs useCallback

1. useMemo
  * 함수의 결과를 cache하기 위해 사용
    * "Expensive" computation
    * ***React는 1ms 이상 걸리면 'expensive'라고 칭함***
    * "Expensive"하지 않다면 굳이 필요 없다.
  * 조건에 따른 컴포넌트를 리턴할 때 사용하거나 특정 변수를 계산할 때
  * 초기렌더링보다는 cache되는 것을 고려할 때 re-rendering에 유리함
    * https://github.com/yeonjuan/dev-blog/blob/master/JavaScript/should-you-really-use-usememo.md?utm_source=substack&utm_medium=email
    * 요약하면 시간복잡도를 n으로 칭할 때, n > 100일때만 심하게 유리함
2. useCallback
  * 함수 자체를 cache하기 위해 사용
  * dependency를 확인해야 하는 함수일 때
  * ChildComponent에 prop으로 넘겨주는 함수일 때


useCallback
1. 함수를 왜 cache하는가?
2. JavaScript 언어 특성

```javascript
import React, { useState, useCallback } from 'react';

function ChildComponent({ onClick }) {
  console.log('childComponent re-rendered');
  return <button onClick={onClick}>Click me</button>;
}

function ParentComponent() {
  const [count, setCount] = useState(0);

  const handleClick = useCallback(() => {
    setCount((prevCount) => prevCount + 1);
  }, []);

  console.log('ParentComponent re-rendered');

  return (
    <div>
      <h1>Count: {count}</h1>
      <ChildComponent onClick={handleClick} />
    </div>
  );
}
```

useMemo vs useCallback

1. Sendbird repo에서 사용법 확인
2. 좋은 코드를 계속해서 보는 것이 중요함
  * 처음 프로젝트 아키텍처 잡았던 경험
3. https://github.com/sendbird/quickstart-calls-reactjs

<br>
<br>

React 18에서 새롭게 소개된 hook들

1. useId
2. useTransition
3. useDeferredValue
4. useSyncExternalStore
5. useInsertionEffect

기타 hook들

1. useEffect
  * useEffect 왠만하면 필요 없다.
2. useLayoutEffect
3. useRef

<br>
<br>

전역 상태 관리 툴 소개 (ContextAPI, Redux, Recoil)

전역 상태 툴 - Context API

1. 기본 제공 툴
2. Provider를 사용해서 Components들에 'state'를 'provide'하는 방식
3. 장점
  * 매우 간단함
  * 추가 패키지를 설치하지 않아도 됨
4. 단점
  * 비즈니스 로직에 따라서 Provider를 생성해줘야함
    * 코드가 복잡해질 수 있음
  * 렌더링 효율에 좋지 않음
5. Sendbird repo 참고 설명
  * Custom hook을 선언해서 reducer를 사용하는 방식
  * https://github.com/sendbird/quicstart-calls-reactjs/tree/main/sample-01


전역 상태 툴 - Redux

1. 모든 상태를 store에 저장함
  * Context API가 context별로 reducer를 따로 사용하는 것과 반대됨
2. Read-only states
  * useReducer와 유사하게 'dispatch'를 통해서만 상태를 업데이트 할 수 있음
  * store를 직접적으로 mutate할 수 없음
3. 장점
  * Redux DevTools등을 활용한 비교적 쉬운 debugging
  * Middleware: saga, thunk, persistent
4. 단점
  * 구조가 복잡함
  * 사이즈가 작을 경우 불필요한 overhead
5. https://github.com/reduxjs/redux/tree/master/examples


전역 상태 툴 - Recoil

1. Facebook에서 만들었음
2. atoms and selectors라는 개념
  * 내가 필요한 값만 'subscribe'하는 느낌
  * atom은 일반적인 state와 유사한 개념
  * selector는 atom을 Manipulate 해야하는 경우 사용됨
3. 장점
  * 구조가 간단해서 적용하기 쉬움
  * ContextAPI의 rendering 비효율을 개선함
  * React 상태관리를 위해서 만들어짐
4. 단점
  * 사용자가 아직은 그렇게 많지 않음
  * middleware의 부재
  * https://github.com/saseungmin/Recoil_ToDo

<br>
<br>

```javascript
```
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>


2회차 이야기
1. useState는 컴포넌트 내에서 사용 
  a. Batch
  b. Update queue
2. useReducer는 가급적 Context API와 같이
3. useMemo는 1ms이상 걸리는 경우
4. useCallback은 가급적 child에게 내려주는 prop인 경우에
5. useEffect는 가급적 쓰지마라
6. 전역상태 툴은 상황에 맞는걸로 사용하면 된다