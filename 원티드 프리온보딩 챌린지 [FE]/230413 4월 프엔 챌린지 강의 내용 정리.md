230413 4월 프엔 챌린지 강의 내용 정리

<br>

### 3회차 recap

1. Lighthouse 
  a. 점수로 볼 수 있음
  b. Web vital 측정
  c. 완전 정확하지는 않은듯
2. Performance 
  a. 각 step별 소요시간 확인 가능
3. Profiler
  a. 컴포넌트, jsx tag 별 렌더링 시간 확인 가능
  b. 디버깅에 유용


### Server-Side Rendering vs Client-Side Rendering
- Next.js 가 많이 뜨면서 Server-Side Rendering이 많이 회자가 됐고,
  React 18부터는 리액트 자체의 하이드레이트? 기능을 지원하면서 Next.js를 안쓰고도 서버 사이드 렌더링이 가능한데
  예전에는 서버 사이드 렌더링을 할거면 무조건 Next.js를 써야한다는게 있었음
- Server-Side Rendering이 더 오래된 기술임
  처음에 컴퓨터가 나왔을때는 컴퓨터 성능이 좋지 않아서 서버에서 모든 파일을 만들어서 html에?을? 전달했다.
  => 요즘 Next.js에서 쓸 수 있는 Static Side Generation이다.

1. 웹개발의 역사를 이해하면 조금 도움됨
2. Static Site Generation
  a. 이미 만들어진 html파일들을 불러오는 것 (예를 들어 개츠비? 블로그를 할 때 작성한 블로그의 html 파일들이 서버에 있으면 그걸 그대로 가져온다)
  b. /home, /list, /mypage 등등에 접근할 때마다 해당 html파일을 호출해서 가져옴
3. AJAX
  a. html 뿐만 아니라 json으로 데이터를 주고받을 수 있게 됨
  b. HTML파일을 가져오고,
  c. JavaScript를 활용해서 서버에 데이터를 호출
  d. 데이터를 json으로 받아와서 화면에 보여줌
  e. SPA 등장 - 그러면서 리액트를 비롯한 클라이언트 사이드 렌더링이 뜨기 시작함

```
네, 리액트 18부터는 Next.js 없이도 서버사이드 렌더링(SSR)을 구현할 수 있습니다. 이전에는 Next.js가 SSR을 구현하기 위한 주요 도구였으나, 리액트 18에서는 SSR을 쉽게 구현할 수 있는 리액트의 기본 기능으로 통합되었습니다.

리액트 18에서 SSR을 사용하려면 ReactDOMServer를 사용하여 서버에서 컴포넌트를 렌더링하고 초기 상태를 전달하는 방식으로 작업할 수 있습니다. 이를 통해 서버에서 렌더링된 HTML을 클라이언트로 보내고, 클라이언트에서는 해당 HTML을 재사용하여 초기 렌더링을 수행할 수 있습니다.

리액트 18에서는 SSR을 구현하기 위한 몇 가지 개선 사항과 API가 도입되었습니다. 예를 들어, Suspense를 사용하여 서버에서 데이터를 로드하는 동안 로딩 상태를 관리하고, 서버에서 생성된 상태를 클라이언트로 전달하여 초기 렌더링에서 재사용할 수 있습니다.

리액트 18은 아직 출시되지 않았지만, 이러한 새로운 기능과 개선 사항이 포함될 것으로 예상됩니다. 현재까지 공개된 정보에 따르면, 리액트 18에서는 SSR을 구현하기 위한 도구와 기능이 향상될 것이며, Next.js 없이도 SSR을 쉽게 구현할 수 있을 것으로 기대됩니다.
```


### Client Side Rendering

1. 서버에서 `index.html`을 클라이언트에게 전송
  a. `index.html`에는 아무것도 없음
  b. `main.tsx` (원래는 app.js) 에서 application에서 필요한 소스코드를 불러옴
2. 장점
  a. 요즘 트렌드
  b. 개발편함
3. 단점
  a. 소스코드가 커서 첫 로딩이 오래걸림 (사용자가 빈 화면을 보고있을 수도 있다)
  b. SEO에 안좋음 왜냐면 `index.html`이 비어있기 때문에 (크롤링할 때 가져올게 없어)

```html
<!-- 코드는 전에 강사님이 만드셨던 바이트로 만든 index.html -->
<body>
  <div id="root"></div>
  <script type="module" src="/src/main.tsx"></script>
</body>
```


### Server Side Rendering

1. Static이 사실 Server Side Rendering 의 시작
  a. 컴퓨터 성능이 좋아지면서 Client Side Rendering이 떴다가 SEO 등의 문제로 인해 다시금 Server Side Rendering이 뜨는 추세
2. 서버에 접근하면 `index.html`을 만들어서 전송함
  a. 비어있지 않아서 CSR보다 렌더링 빠름
  b. 자바스크립트 코드를 index.html과 같이 보내줌
3. 장점
  a. 초기 로딩이 빠르다는 장점
    * Client Side Rendering의 경우에는 사용자가 빈 화면을 보게 될 수도 있었지만,
    Server Side Rendering 같은 경우에는 이미 만들어진 index.html이 넘어오니까 빈 화면을 아예 안보거나 좀 더 빠르게 화면을 볼 수 있다.
  b. index.html에 이것저것(ex.<meta>) 들어있어서 SEO(검색 최적화)에 좋음
  * https://yozm.wishket.com/magazine/detail/816/ - 메타태그가 뭐였는지 까먹음
4. 단점
  a. `index.html`을 서버에서 계속해서 다시 불러오는 것
  b. 서버에 지속적인 요청을 보내기 때문에 여러 명이 동시에 페이지에 접근하게되면 서버에 부하가 걸릴 수 있음
  c. index.html에 동적인 JavaScript가 붙을때까지 interactive하지 않음


----

앵간하면 Server Side Rendering이 좀 더 빠르다.
But, 무조건 좋은건 아닌게 데이터를 계속해서 서버에서 불러와야하는데 
불러올 때 만약 내 화면에서 http 통신을 계속해야하면 CSR이 나을 수도 있다.
이유는 Server Side에서 이미 다 만들어 줬는데 html에서 데이터 전송을 다시 요청하면 화면이 또 바뀌어야하니,,
결국 이미 서버에서 작업이 다 되어져 보여줄 수 있는 대시보드나 블로그 같은 경우에는 SSR이 확실히 유리한데,
만약 서버와 클라이언트 사이에 interaction이 많아야하는 경우에는 CSR이 나을 수 있다.
강사님 개인적인 생각으론 SEO 안할거면 굳이 SSR 필요없는 것 같아요...

-----

Q. 서버에 부하가 걸린다는 기준이 무엇인가요?
A. 굉장히 주관적입니다. 서버가 터진다거나 현저히 느려지는 것을 부하가 걸린다고 하는데,.
   일반적으로 보면 포트가 655 355? 까지 있잖아요?
   그래서 제 생각에는 655 355 명까지는 부하가 걸릴 일이 없고, 그 이후부터 문제가 된다고 봅니다.
   근데 그것도 뭐 분산하면 되지 않을까 싶긴한데, 서버에서 평소보다 처리가 느려진다거나 할 때 부하가 걸렸다고들 합니다.

Q. 방금 말씀하신 포트에 관련해서 더 알 수 있을까요?
A. 포트는 사실 html에 관련된 직접적인 내용은 아니구요.
   만약 한 서버가 여러개의 작업을 처리한다고 하면 포트의 갯수가 정해져있어요.
   1~65535... 귀찮으니 넘어가도 될거같음

Q. CSR은 그러면 index.html, app.tsx를 처음에 받아오고 app.tsx에서 데이터를 다시 요청하는 건가요?
A. 네 맞습니다. 비어있는 index.html을 가져와서 app.tsx에서 같이 요청을 보내는 것~

Q. SSR을 꼭 해야하는 경우는 언제인가요?
A. SEO가 필요할때. + 
   그리고 이제 서버에서 데이터를 처리해주니까 
   예를 들어 대시보드에 row가 1억개 있다고 가정했을때
   1억개를 Analyze해서 평균이나 근사치를 나타낸다고 하면
   서버에서 데이터를 처리해서 보여주는게 더 빠를 것이다.
   요청은 보내게 되면 그것들을 처리하는 시간동안 기다려야하니까! ....

   결론: 사용자 입장에서 서버에 이미 데이터가 많이 들어가있고 그것을 계속해서 요청할 필요가 없을 때나 
   SEO(검색 최적화)를 할 때

Q. 그럼 모바일 어플리케이션은 SSR이 필요 없는 건가요?
A. 모바일 어플리케이션은 SSR이라고 보기 어렵다. 앱 자체에 있는 것을 띄워주는 것 번들링 된거를!
   좀 차이가 있는 것 같다.
   왜냐하면 모바일 어플리케이션은 인터넷 연결 안되어있어도 보여줄 수 있기 때문.
   SSR이 없다? ㅇㅇ...

Q. CSR의 경우에도 index.html 파일이 컴파일되는데 SSR과 컴파일 되는 과정이 어떤 식으로 되는지 궁금합니다.
A. 12:35  별말 아님 강사님 추측으로는 서버에서 만드냐 안만드냐의 차이인거같다고 하심

-----


### Static Site Generation

1. React + Gatsby
2. `index.html`들을 생성해서 서버에 미리 배포하는 것
  * 파일들을 이미 서버에 만들어놓고 그걸 던져줌
3. JavaScript 파일을 얹어서 주면 동적으로도 작동할 수 있음


### Frontend MSA(Micro Service Architecture)
- Architecture(아키텍처) = 컴퓨터 시스템의 하드웨어 구조
- 원래는 서버에서 쓰는 개념인데,,
- 우리나라 서비스는 아직 이럴 단계가 아님에도 불구하고 많이 쓴다고 해서... 솔직히 꼭 필요한지 모르겠다고 하셨당

1. 하나의 프로젝트를 작은 단위로 나누는 것 == 기능별로 서비스를 쪼개는 것!
2. Monolithic vs MSA
  a. 하나가 다 처리하느냐
  b. 여러개로 나눠서 처리하느냐 (사용자 서버, 주문 서버, ,, 이런식으로 나눔)
3. 어느정도 규모(?)가 있는 서비스가 아니라면 MSA는 무의미함

오늘의 집도 MSA
Monolithic Architecture의 배포/운영/관리 비용 증가 문제 방지 +
Command 와 Query 요청을 처리하는 서비스를 분리(CQRS)하고, 
이중 Query 서비스를 최적화하여 10배 이상의 성능 향상 +
BFF(Backend For Frontend)를 활용한 BE와 FE 간의 의존성 최소화
를 이유로~

추측해보면 의존성이 적어서 에러도 적고, 소스 코드 파악도 쉬울것...
팀을 작게 유지하기도 좋고..

----

Q. 그럼 서로 쪼개져있어서 오히려 서비스 간 통신이 복잡해지진 않나요.
A. 16:30 (백엔드 부분 정리가 귀찮음. 대충 그렇지 않다! 통신이 필요하지 않은 부분이다. 백엔드에선 얘기가 달라지지만..) (백엔드에선 카프카같은걸로 소통한다고 합니뎅)

----

### Backend for Frontend

1. Backend를 Frontend에 맞추는 것
2. MSA(Micro-service Architecture)가 주목 받으면서 등장함
3. Web, Mobile, Desktop 등 프론트엔드의 니즈에 맞게 서버를 따로 구축함
4. 읽을거리
  a. https://fe-developers.kakaoent.com/2022/220310-kakaopage-bff/
    * 서버가 아닌 프록시를 따로 하는거라고 함


### 프론트엔드 디자인패턴 (20:15)
- 문서를 열심히 읽어보자~ 

1. 요즘은 거의 atomic + react-query
2. 디자인패턴 - https://yozm.wishket.com/magazine/detail/1663/
3. Atomic - https://yozm.wishket.com/magazine/detail/1531/
4. 최선의 디자인 패턴은 없음
  a. 필요에 맞게
  b. 컨벤션에 맞게
  c. `요즘 이게 힙하니까 이걸 따른다`는 하지 않아도 됨


### 테스트코드

1. Unit Test - 하나만 보고 너 잘돌아가니?
  a. 함수, 컴포넌트가 독립적으로 잘 작동하는지 확인하는 것
  b. 디펜던시 신경 안쓰고 이게 잘 되나요??
2. Integration Test - Unit Test 합친 것을 보고 너그들 잘 돌아가니?
  a. 여러 함수들 또는 여러 컴포넌트들이 같이 잘 동작하는지 확인하는 것
3. E2E test
  * 이 친구를 하려면 싸이프레스(Cypress)를 써야하는데 GUI..
  * https://velog.io/@_woogie/E2E%ED%85%8C%EC%8A%A4%ED%8A%B8-with-Cypress
  * Integration Test로도 충분하게 느껴졌다고 하심
  a. 사용자인것마냥 테스트 하는 것


[아하!모먼트] 취업/이직을 준비하는 나만의 방법
1. 분기별 이력서 업데이트
a. 이직을 하지 않더라도 평가시즌/연봉협상 할 때 좋음 b. 내가어떤업무를했는지실적위주로기록
i. 단순히뭘했다보다는이걸해서뭐가어떻게좋아졌다
2. 이력서 커스텀
a. 지원하는회사공고를보고회사에맞게내용을수정
i. 회사별로 중요하게 보는게 다르기 때문
ii. 해당 회사에서 중요하게 생각하는 역량을 어필하기 위함
3. 이력서 공유
a. 원티드 등 플랫폼에 이력서 공유
b. `좋은 제안이 오면 이직할 생각이 있다`