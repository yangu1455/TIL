# 한입 크기로 잘라 먹는 리액트(React.js) : 기초부터 실전까지

# 10일차 강의 내용 정리

### 동기 & 비동기

<br>

예를 들어 아래의 작업들을 순서 상관없이 실행시켜야 한다고 가정해보자.

```javascript
function taskA() {
  console.log("TASK A");
}

function taskB() {
  console.log("TASK B");
}

function taskC() {
  console.log("TASK C");
}

taskA();
taskB();
taskC();
```

<br>

> 연산과정을 수행하는 일꾼 = 스레드  
> 스레드는 코드를 한줄씩 실행시켜주는 아이임

<br>

자스는 코드가 작성된 순서대로 작업을 처리하고, 먼저 작성된 코드가 다 실행되고 나면 뒤에 작성된 코드를 실행한다.  
=> 동기 방식의 처리

스레드에서 작업을 하고 있을 때 다른 작업을 동시에 할 수 없는 것  
=> 블로킹 방식

> 동기적 처리 방식의 문제점 : 오래 걸리는 하나의 작업이 종료되기 전까지 모든 작업이 올스탑, 전반적으로 느려진다.
> 그래서 스레드를 여러개 사용해 작업을 분할 하는 '멀티 스레드' 방식을~!
> 근데 자스는 싱글 스레드로 동작...(절망)

> 그래서 여러 개의 작업을 동시에 실행시키는 방식을 택한다. => 비동기 방식의 처리 & 논블로킹 방식

정상적으로 끝났는지! 그리고 작업의 결과가 어떻게 나온지를 확인해보자.  
작업이 끝나면 실행하라는 콜백 함수를 붙여서 전달한다.

```javascript
taskA(resultA => {
  console.log(`A 끝났습니다. 작업 결과 : ${resultA}`);
});

taskB(resultB => {
  console.log(`B 끝났습니다. 작업 결과 : ${resultB}`);
});

taskA(resultC => {
  console.log(`C 끝났습니다. 작업 결과 : ${resultC}`);
});
```

코드로 확인하는 동기와 비동기

```javascript
// 동기 처리
function taskA() {
  console.log("A 작업 끝");
}

taskA();
console.log("코드 끝");

// 비동기 처리
function taskA() {
  setTimeout(() => {
    console.log("A TASK END");
  }, 2000);
}

taskA();
console.log("코드 끝"); // 먼저 출력됨
```

```javascript
// 비동기 처리의 결과값 이용하고 싶을때는 콜백함수를 사용하자!

function taskA(a, b, cb) {
  setTimeout(() => {
    const res = a + b;
    // 지역상수 res
    // 스코프 안에서만 유효한 상수 => 지역상수~
    // 지역상수를 바깥에서 사용하고 싶으면 콜백함수를 이용하면 됨!
    cb(res);
  }, 3000);
}

taskA(3, 4, res => {
  console.log("A TASK RESULT : ", res);
});
console.log("코드 끝");
```

```javascript
```

```javascript
```

```javascript
```

```javascript
```

```javascript
```

```javascript
```
